# MDC

## 1. MDC의 기본 개념
- **핵심**: MDC는 각 쓰레드에 대해 고유한 정보를 저장하는 매커니즘입니다. 이를 통해 로그에 해당 쓰레드의 컨텍스트를 자동으로 추가할 수 있습니다.
- **왜 중요한가**: 로그에 어떤 쓰레드가 어떤 작업을 하고 있는지 명확하게 기록할 수 있습니다. 여러 사용자가 동시에 요청을 처리할 때, 특정 요청이나 작업과 관련된 로그를 쉽게 추적할 수 있습니다.

```java
MDC.put("userID", "user123");
logger.info("Request processing started");
MDC.clear();
```

위 코드에서 `MDC.put("userID", "user123")`를 통해 쓰레드별로 사용자 정보를 로그에 포함시킵니다. 나중에 로그에서 이를 통해 특정 요청의 흐름을 파악할 수 있습니다.

## 2. MDC 설정 및 해제 방법
- **핵심**: MDC는 쓰레드별로 설정되기 때문에, 각 쓰레드에서 작업을 시작할 때 설정하고, 작업이 끝나면 반드시 해제(`MDC.clear()`)해야 합니다.
- **왜 중요한가**: MDC 설정이 유지된 상태로 쓰레드가 재사용되면, 잘못된 정보가 다른 작업에 영향을 미칠 수 있습니다. 그러므로 설정 후 해제하는 절차가 필수적입니다.

### 실전에서 해야 할 일:
요청을 처리하는 주요 진입점(예: 컨트롤러 시작 부분)에 MDC 설정 코드를 추가하고, 요청이 끝나면 MDC를 해제하세요.

```java
try {
    MDC.put("requestID", "abcd1234");
    // 처리 로직
} finally {
    MDC.clear();
}
```

## 3. 멀티 쓰레드 환경에서의 유용성
- **핵심**: 여러 쓰레드가 동시에 로그를 남길 때, 특정 쓰레드에서 발생한 작업을 구분할 수 있게 해줍니다. 예를 들어, 웹 서버가 여러 사용자의 요청을 동시에 처리할 때 각 사용자의 요청 ID나 세션 정보를 로그에 기록해 두면 문제 해결이 훨씬 수월해집니다.
- **왜 중요한가**: 복잡한 애플리케이션에서 특히 중요한데, 특정 사용자나 요청과 관련된 오류를 추적할 때 도움이 됩니다.

### 적용 상황 예시:
웹 애플리케이션에서 각 요청마다 고유한 요청 ID를 부여하고, 해당 ID로 로그를 남기면, 나중에 로그를 분석할 때 어느 사용자의 요청에서 오류가 발생했는지 쉽게 찾을 수 있습니다.

## 4. MDC 활용의 고도화
- **다양한 컨텍스트 관리**: MDC를 사용하면 단순히 한 가지 정보만 저장하는 게 아니라, 여러 가지 컨텍스트 정보를 저장하고 활용할 수 있습니다. 예를 들어, 사용자 ID뿐만 아니라 트랜잭션 ID, 세션 ID 등 다양한 정보를 동시에 MDC에 넣을 수 있습니다.

### 실전 적용 시:
복잡한 애플리케이션에서 여러 정보를 로그에 남겨야 한다면, 어떤 정보를 우선순위로 기록할지, 그리고 어떻게 다중 정보를 효율적으로 관리할지 고민해야 합니다.

- **추가 질문**:
   - "어떤 경우에 MDC에 여러 정보를 저장하는 것이 유리할까?"
   - "MDC에 너무 많은 정보를 넣으면 성능에 영향을 줄까?"

## 5. MDC와 비동기 작업
- **문제점**: MDC는 기본적으로 쓰레드에 바인딩됩니다. 하지만 비동기 환경에서는 새로운 쓰레드나 작업 단위로 작업이 넘어가면서 MDC 컨텍스트가 유지되지 않을 수 있습니다.
- **해결 방법**: 비동기 작업이나 스레드 풀을 사용할 때, MDC 컨텍스트를 전파하는 방법을 알아야 합니다.

- **추가 질문**:
   - "비동기 환경에서 MDC 컨텍스트를 어떻게 안전하게 유지할 수 있을까?"
   - "MDC가 비동기 작업에서도 정확히 로그를 남기려면 추가로 무엇을 설정해야 할까?"

### 해결 방법:
대부분의 프레임워크나 라이브러리에서는 MDC 전파를 지원하는 기능들이 있지만, 경우에 따라서는 수동으로 전파하는 코드가 필요할 수도 있습니다. 예를 들어, `Callable`이나 `Runnable`을 사용할 때 MDC 컨텍스트를 복사하고 새로운 스레드에 설정하는 코드를 작성할 수 있습니다.

## 6. MDC와 성능 고려 사항
- **문제점**: 로그에 너무 많은 MDC 정보를 담을 경우 성능에 영향을 미칠 수 있습니다. 예를 들어, 로그 파일이 지나치게 커지거나, 성능 저하로 이어질 수 있는 상황이 발생할 수 있습니다.
- **성능 최적화 방법**: 필요한 최소한의 정보를 MDC에 저장하고, 불필요한 컨텍스트는 줄이는 방향으로 관리해야 합니다.

- **추가 질문**:
   - "MDC 사용 시 성능 문제를 어떻게 최적화할 수 있을까?"
   - "로그에 꼭 필요한 정보만 남기기 위한 전략은 무엇인가?"

## 7. MDC와 로그 분석 도구 연동
- **확장성**: MDC는 단순한 로그 파일에만 정보를 기록하는 게 아니라, ELK(Elasticsearch, Logstash, Kibana) 스택 같은 로그 분석 도구와도 잘 통합될 수 있습니다. 이를 통해 중앙에서 로그를 모니터링하고, 각 요청의 흐름을 더 쉽게 추적할 수 있습니다.
- **연동 시 고려 사항**: MDC에 저장된 컨텍스트 정보가 로그 분석 도구에서 어떻게 필터링되고 검색될 수 있는지 이해해야 합니다.

- **추가 질문**:
   - "MDC로 남긴 로그를 ELK 스택과 연동하려면 어떻게 설정해야 할까?"
   - "로그 분석 도구에서 MDC로 남긴 정보를 더 쉽게 검색할 수 있는 방법은?"

---

# 로깅 및 트레이싱 도구 비교 표

| **도구**                          | **목적**                                                        | **적용 범위**                           | **특징**                                                         | **설정 난이도** | **비고**                                                            |
|------------------------------------|-----------------------------------------------------------------|-----------------------------------------|------------------------------------------------------------------|-----------------|-------------------------------------------------------------------|
| **MDC (Mapped Diagnostic Context)** | 쓰레드별 고유한 컨텍스트 정보(예: 사용자 ID, 요청 ID)를 로그에 포함. | 단일 애플리케이션, 멀티쓰레드 환경        | 간단한 설정, 쓰레드마다 고유한 정보 관리. 비동기 환경에서는 추가 작업 필요. | 낮음            | 간단하고 효과적인 로깅 솔루션. 분산 시스템이 아닌 경우 적합.           |
| **ThreadLocal**                    | 쓰레드별 고유 데이터 저장.                                       | 단일 애플리케이션, 멀티쓰레드 환경        | 사용자 정의 데이터를 쓰레드별로 관리 가능. 직접 로깅과는 연동되지 않음.      | 중간            | 단순 데이터 저장에 적합. 로깅과 연동하려면 직접 처리해야 함.            |
| **Spring Cloud Sleuth**            | 마이크로서비스 간 트랜잭션 추적. Trace ID와 Span ID를 자동 부여.  | 분산 시스템, 마이크로서비스               | 각 요청에 고유한 Trace ID를 부여하고, 서비스 간 요청 흐름을 추적 가능.       | 중간            | 스프링 부트와 잘 통합. 대규모 분산 시스템에서 효과적.                   |
| **Distributed Tracing Tools** (Zipkin, Jaeger) | 분산 시스템에서 서비스 간 요청의 흐름 추적 및 시각화.                | 대규모 분산 시스템, 마이크로서비스        | Trace ID, Span ID로 분산 환경에서 트랜잭션 흐름 시각화 및 모니터링.          | 높음            | 추가적인 인프라 설정 필요. 대규모 시스템에서 트랜잭션 추적에 적합.       |
| **Correlation ID 패턴**            | 각 요청에 고유한 ID를 부여하여 요청 흐름 추적.                     | 단일/분산 시스템, 마이크로서비스          | 각 서비스 간 호출마다 동일한 ID를 사용하여 로그 추적.                        | 중간            | MDC와 함께 사용 가능. 대규모 시스템에서 서비스 간 호출 추적에 유용.      |
| **SLF4J MDC**                      | SLF4J 로깅에 쓰레드별 고유한 컨텍스트 정보를 포함.                 | 단일 애플리케이션, 멀티쓰레드 환경        | SLF4J와 연동하여 로깅에 고유 정보 포함. 쓰레드마다 컨텍스트를 구분

가능.     | 낮음            | Logback과 유사한 방식. SLF4J 기반 애플리케이션에 적합.                  |
| **Log4j NDC** (Nested Diagnostic Context) | 계층적 로그 정보 관리. 재귀적 작업 흐름에서 로그 계층을 추적.         | 단일 애플리케이션, 멀티쓰레드 환경        | 계층적인 컨텍스트를 추가하여 재귀적 로그 구조를 관리할 수 있음.              | 중간            | Log4j에서 사용. 재귀적 호출이나 계층적 구조에서 유용.                   |
| **OpenTelemetry, OpenTracing**     | 분산 시스템에서 표준화된 방식으로 트랜잭션 흐름 추적.              | 대규모 분산 시스템, 마이크로서비스        | 표준화된 트레이싱 프로토콜을 사용하여 서비스 간 요청을 추적하고 모니터링.    | 높음            | 대규모 분산 시스템에서 성능 모니터링과 트랜잭션 추적에 유리.            |

## 요약

- **MDC**는 간단한 쓰레드별 로깅에 적합하며, 설정과 적용이 매우 쉬운 장점이 있습니다.
- **ThreadLocal**은 쓰레드별 데이터를 저장할 수 있지만, 자동으로 로깅과 연동되지는 않습니다.
- **Spring Cloud Sleuth**는 마이크로서비스 간의 요청 추적에 적합하며, 스프링 부트와 잘 통합됩니다.
- **Zipkin**, **Jaeger** 같은 도구는 대규모 분산 시스템에서 각 서비스 간의 요청 흐름을 시각적으로 추적할 때 매우 유용하지만, 추가적인 설정이 필요합니다.
- **Correlation ID 패턴**은 모든 시스템에서 고유 ID를 활용해 간단하게 요청 흐름을 추적할 수 있는 방식입니다.
- **SLF4J MDC**는 SLF4J 기반 프로젝트에서 MDC와 유사한 방식으로 쓰레드별 로깅을 처리합니다.
- **Log4j NDC**는 계층적인 로그 관리에 유용하지만, 최근에는 덜 사용됩니다.
- **OpenTelemetry**와 **OpenTracing**은 대규모 분산 시스템에서 표준화된 트레이싱을 제공하는 도구로, 복잡한 시스템에서 유용합니다.
```